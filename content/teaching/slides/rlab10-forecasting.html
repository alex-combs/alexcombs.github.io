<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>PADP 7120 Data Applications in PA</title>
    <meta charset="utf-8" />
    <meta name="author" content="Alex Combs" />
    <meta name="date" content="2020-12-02" />
    <link rel="stylesheet" href="mypres.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# PADP 7120 Data Applications in PA
## RLab 10: Forecasting
### Alex Combs
### UGA | SPIA | PADP
### December 2, 2020

---

# Set-up



- Start a new project and notebook

- Change YAML


```r
---
title: "RLab 10: Forecasting"
author: "Your Name"
output: 
  html_document:
    theme: spacelab
    df_print: paged
---
```

---
# Set-up

- Download the following data available on eLC and add to your project folder


```r
load("sales.RData")
load("voting.RData")
```



---
# Packages

- Remember to set `include=FALSE`


```r
library(tidyverse)
library(forecast)
library(fpp2)
```

---
# Learning objectives

By the end of this lab, you will have learned how to...

- Convert a dataset to a time series dataset in R
- Explore time series for patterns
- Execute some simple forecasting models like naive, average, and (seasonal) trend
- Execute exponential smoothing
- Execute a regression-adjusted forecast
- Evaluate and choose between forecast models

---
# Forecasts

&lt;img src="labs_files/hurricaneforecast.png" width="1231" style="display: block; margin: auto;" /&gt;

---
# Forecasts

&lt;img src="labs_files/hurricanespag.png" width="1121" style="display: block; margin: auto;" /&gt;

---
# Forecasts

&lt;img src="labs_files/tourismspag.png" width="1135" style="display: block; margin: auto;" /&gt;

---
# Forecasts

&lt;img src="labs_files/tourismforecast.png" width="1105" style="display: block; margin: auto;" /&gt;

---
# Steps of forecasting

1. Preliminary/exploratory analysis
2. Choosing and fitting models
3. Using and evaluating a forecasting model

---
# Creating a time series (TS) object

- First, need to tell R that data is time series

- Generic syntax:


```r
ts_name &lt;- ts(data_name[,-1], # tells R to skip the first row of names
              start = first_time_period,
              end = last_time_period, 
              frequency = unit_of_time_between_observations)
```

---
# TS object examples

- annual time series

&lt;img src="labs_files/tsobjannual.png" width="1277" style="display: block; margin: auto;" /&gt;


```r
ts_data &lt;- ts(data[,-1], start = 2012, end = 2016,
              frequency = 1)
```

---
# TS object examples



- quarterly data (head &amp; tail shown)


| year| quarter| value|
|----:|-------:|-----:|
| 2016|       1|    53|
| 2016|       2|    43|



| year| quarter| value|
|----:|-------:|-----:|
| 2020|       3|    49|
| 2020|       4|    54|


```r
ts_quarterly &lt;- ts(quarterly[,-1], start = 2016, end = 2020,
                   frequency = 4)
```

---
# TS object examples

- monthly data (head &amp; tail shown)




| year| month| value|
|----:|-----:|-----:|
| 2016|     1|    74|
| 2016|     2|    61|



| year| month| value|
|----:|-----:|-----:|
| 2020|    11|    41|
| 2020|    12|    50|


```r
ts_monthly &lt;- ts(monthly[,-1], start = 2016, end = 2020,
                   frequency = 12)
```

---
# TS object examples

- biennial data (head &amp; tail shown)




| year| value|
|----:|-----:|
| 2000|    45|
| 2002|    68|



| year| value|
|----:|-----:|
| 2018|    39|
| 2020|    65|


```r
ts_biennial &lt;- ts(biennial[,-1], start = 2000, end = 2020,
                   frequency = 0.5)
```

---
# Frequencies


|Data        |frequency |
|:-----------|:---------|
|Quadrennial |0.25      |
|Biennial    |0.5       |
|Annual      |1         |
|Quarterly   |4         |
|Monthly     |12        |
|Weekly      |52        |
|Daily       |365       |

---
# Creating TS object

- `voting` contains national turnout for each U.S. presidential election from 1912 to 2016

- Try to set `voting` as a TS object on your own


```r
ts_voting &lt;- 
```

--


```r
ts_voting &lt;- ts(voting[,-1], start = 1912, end = 2016, 
                frequency = 0.25)
```

---
# Creating TS object

- `sales` contains data for a social enterprise

- Examine `sales` and try to convert to TS on your own


```r
ts_sales &lt;- 
```

--


```r
ts_sales &lt;- ts(sales[,-1], start = 1981, end = 2005, 
               frequency = 4)
```

---
# Exploratory plotting

- The purpose of exploratory plotting is to detect **patterns**

- Patterns provide information for prediction in the future

- Certain forecast models are better for certain patterns

---
# Types of patterns

1. Trend - A long-term increase or decrease in the data

2. Seasonal - A periodic pattern that follows the calendar (e.g. quarter, month, day of the week)

3. Cyclic - Data rises and falls not according to a fixed period (e.g. recessions)
  
---
# Patterns

&lt;img src="rlab10-forecasting_files/figure-html/unnamed-chunk-27-1.png" style="display: block; margin: auto;" /&gt;

---
# Patterns

&lt;img src="labs_files/patterns-colfinance.png" width="1005" style="display: block; margin: auto;" /&gt;

---
# Exploratory plots

- With a TS object, line graphs can be made very quickly

- Add and run following code


```r
autoplot(ts_voting)
```

```r
autoplot(ts_sales)
```

---
# Exploratory plots

- The sales data exhibits seasonality. There are useful ways to visualize seasonal patterns.

- Add and run following code


```r
ggseasonplot(ts_sales[,1]) #tells R to run on first variable only, sales
```

---
# Exploratory plots

- Suppose we want a subset of the years

- Following code creates a new ts object starting in year 2000. Add and run.


```r
ts_sales2 &lt;- window(ts_sales, start = 2000)
```

- Run `ggseasonplot` on `sales` using `ts_sales2`


```r
ggseasonplot(ts_sales2[,1])
```

---
# Exploratory plots

- Here are a few more options. Add and run.


```r
ggseasonplot(ts_sales2[,1], polar = TRUE)
ggsubseriesplot(ts_sales2[,1])
```

- Run `ggseasonplot` and `ggsubseriesplot` on `GDP` using `ts_sales2`

--


```r
ggseasonplot(ts_sales2[,3], polar = TRUE)
ggsubseriesplot(ts_sales2[,3])
```

---
# Trends

- Exploratory graphs are good for showing patterns to an audience and getting an initial sense for our own forecasts

- Voting seems to be cyclical and sales are clearly seasonal and maybe a slight upward trend

- We can be more scientific than using visualizations...

---
# Autocorrelation

- Correlation measures the linear association between two variables

- **Autocorrelation** measures the linear association between a variable and past values of the same variable

- If past values are correlated with future values, then the past informs the future

--

- **Lag**: term used to refer to a past value

- The 3rd lag for annual time series value for 2020 is 2017

---
# Autocorrelation

&lt;img src="rlab10-forecasting_files/figure-html/unnamed-chunk-35-1.png" style="display: block; margin: auto;" /&gt;

&lt;img src="rlab10-forecasting_files/figure-html/unnamed-chunk-36-1.png" style="display: block; margin: auto;" /&gt;

- Blue dashed line delineates statistically significant correlation

---
# Autocorrelation

- Data with a trend will have large positive residuals for recent lags that decrease over time

- Data with seasonality only will have peaks and valleys that correspond to the seasons that correlate with each other

---
# White noise

- A time series that shows no autocorrelation is called white noise

- Means the time series is random and past values do not predict future values to a statistically significant degree

--

- We can check for white noise **after using a forecast model**

- If the residuals from our forecast are white noise, this means we have extracted all of the useful information from the past to predict the future

---
# Autocorrelation

- We can generate an autocorrelation plot for the `sales` variable. Add and run.


```r
ggAcf(ts_sales[,1])
```

&lt;img src="rlab10-forecasting_files/figure-html/unnamed-chunk-37-1.png" style="display: block; margin: auto;" /&gt;

---
# Autocorrelation

- We can formally (i.e. hypothesis test) test for white noise like so:
  - Null hypothesis is the time series is white noise
  - Alternative hypothesis is the time series is autocorrelated


```r
Box.test(ts_sales[,1], lag = 4) #test based on fourth lag bc quarterly
```

```
## 
## 	Box-Pierce test
## 
## data:  ts_sales[, 1]
## X-squared = 105.12, df = 4, p-value &lt; 2.2e-16
```
--

- Use `ggAcf` and `Box.test` to test for autocorrelation in `ts_voting`



---
# Simple Forecasting Models

1. Mean - future values predicted to equal average over time
  - No trend pattern
  - Cyclic or seasonal pattern around what appears to be a stable mean

--

2. Naive - future values predicted to equal most recent value
  - No trend pattern

--

3. Drift - draw line from first to last value and extrapolate
  - Strong trend

--

4. Seasonal Naive - same as naive but predicts each season as equal to its most recent season

---
# Simple forecast models

&lt;img src="labs_files/forcastcompare1.png" width="1347" style="display: block; margin: auto;" /&gt;

---
# Simple forecast models

&lt;img src="labs_files/forecastcompare2.png" width="1339" style="display: block; margin: auto;" /&gt;

---
# In R

- General syntax


```r
new_object &lt;- forecast_model(tsdata, h = periods into future)
```

- Default for `h` is 10 periods
- Period corresponds to frequency; h = 4 in quarterly is one year

- Simple model functions


```r
meanf()
naive()
rwf(drift = TRUE)
snaive()
```

---
# In R

- Let's run `meanf`, `naive`, and `snaive` on `sales` using the `ts_sales` data


```r
sales_meanf &lt;- meanf(ts_sales[,1], h = 12)
sales_naive &lt;- naive(ts_sales[,1], h = 12)
sales_snaive &lt;- snaive(ts_sales[,1], h = 12)
```

- These new objects are like the regression results we have saved many times
- We can use functions on these to view our results

---
# Viewing forecasts in R

- Use `autoplot` for a quick visualization. Visualize each of our three sales forecasts.


```r
autoplot(sales_meanf)
```

&lt;img src="rlab10-forecasting_files/figure-html/unnamed-chunk-45-1.png" style="display: block; margin: auto;" /&gt;



---
# Viewing forecasts in R

- Use `summary` for quantities. Let's report the numbers from what is likely the best forecast of the three.


```r
summary(sales_snaive)
```

---
# Evaluating forecasts

- Similar to evaluating goodness-of-fit from before

- We can compare our point forecast to each observed year of the outcome

- The difference between the observed value and our point forecast is the residual

- We prefer the model with the best fit

--

- Must achieve two things to have a valid forecast:
  - The residuals are white noise
  - The residuals have a mean equal to 0

---
# Evaluating forecasts

- Use `checkresiduals` to test whether our forecast is valid


```r
checkresiduals(sales_snaive)
checkresiduals(sales_meanf)
```

- Use `accuracy` to compare the fit of competing valid models


```r
accuracy(sales_snaive)
accuracy(sales_meanf)
```

- Which is the better model? How far off is it, on average?

---
# Exponential smoothing

- Combines naive and mean models
- Assigns a descending weight to each past value

&lt;img src="labs_files/expsmooth.png" width="1184" style="display: block; margin: auto;" /&gt;

---
# Exponential smoothing

- Can also incorporate trend

&lt;img src="labs_files/expsmooth-trend.png" width="1341" style="display: block; margin: auto;" /&gt;

---
# Exponential smoothing

- Can also incorporate seasonality

&lt;img src="labs_files/expsmooth-season.png" width="1349" style="display: block; margin: auto;" /&gt;

---
# In R


```r
# simple exp smoothing; R automates best alpha
ses(tsdata, h = )
# exp smoothing with trend
holt(tsdata, damped = TRUEorFALSE)
# exp smoothing with trend and seasonality
hw(tsdata, seasonal = "additiveORmultiplicative")
```

---
# In R

Let's use exponential smoothing to forecast sales


```r
sales_ses &lt;- hw(ts_sales[,1], h = 12, seasonal = "additive")
```

- Does this forecast perform better than `sales_snaive` forecast?

- Provide the graph and estimates for using the more accurate model.



---
# Sales Forecast


```r
autoplot(sales_ses)
```

![](rlab10-forecasting_files/figure-html/unnamed-chunk-56-1.png)&lt;!-- --&gt;


---
# Time series regression forecasts

- Other factors can (often) improve our forecasts

- We can incorporate these concepts into regression

`$$y_t=\beta_0+\beta_1x_t + \beta_3t + \beta_4s_t + \epsilon_t$$`

- `\(t\)` controls for each period, like year, to add trend
- `\(s\)` controls for seasons, like quarters, to add seasonality

---
# In R

- Let's forecast sales incorporating GDP and AdBudget


```r
sales_reg &lt;- tslm(Sales ~ AdBudget + GDP + trend + season, data = ts_sales)
```

- Does this forecast perform better than `sales_ses` forecast?

---
# Using a regression on new data

- When we save regression results, we can feed new data into that model for predictions

- General syntax


```r
new_object &lt;- forecast(reg_results, newdata = name_of_newdata)
```

---
# In R

- Now we can forecast sales given new scenarios with respect to the explanatory variables

- Download the `sales_forecast_data.RData` file and add to your project folder. Load these data.


```r
load("sales_forecast_data.RData")
```



- These data suppose a 50% reduction in advertising and constant GDP over the next 12 quarters

---
# In R


```r
fc_sales_reg &lt;- forecast(sales_reg, newdata = sales_forecast_data)
```

- Now we can report these results same as before. Add and run.


```r
autoplot(fc_sales_reg)
```

```r
summary(fc_sales_reg)
```

---
# Recap

- Only scratched surface; time series and forecasting is its own course

--

- Identify patterns to inform which model to use

- If time series is white noise, past values aren't great for forecasting

- Consider regression

--

- Exponential smoothing is one of the most common methods; include trends and seasonality as needed

- Check residuals and accuracy to determine best model

--

- To learn more on forecasting with R: [https://otexts.com/fpp2/](https://otexts.com/fpp2/)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false,
"highlightlines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
